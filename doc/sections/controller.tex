\section{Contrôleur}

\subsection{Description}

\subsection{Interface}

\subsubsection{Entrées}

\begin{tabular}{|l|r|l|}
\hline
\textbf{Port}		& \textbf{Taille} & \textbf{Description}\\
\hline

\texttt{Inst}		& \texttt{16} & Instruction à traiter\\
\hline
\texttt{Flags}		&  \texttt{4} & Drapeaux en entrée, ordre \texttt{NZCV}\\
\hline
\texttt{Clk}		&  \texttt{1} & Horloge\\
\hline
\texttt{Reset}		&  \texttt{1} & Remise à Zero\\
\hline


\hline
\end{tabular}


\subsubsection{Sorties}

\begin{tabular}{|l|r|l|}
\hline 
\textbf{Port} & \textbf{Taille} & \textbf{Description}\\
\hline

\hline
\texttt{Carry}		&  \texttt{1} & Retenue sortante (provenant des drapeaux) à destination de l'ALU\\
\hline
\texttt{DP\_Shift}	&  \texttt{1} & Provenance du nombre de décalages: 0 pour registre A, 1 pour Imm5 \\
\hline
\texttt{Imm8\_Enable}	&  \texttt{1} & Provenance de la donnée A: 0 pour registre, 1 pour Imm8\\
\hline
\texttt{Imm5}		&  \texttt{5} & Nombre de décalage pour les instructions de décalage de la catégorie \textit{Shift, add, sub, mov}\\
\hline
\texttt{Imm8}		&  \texttt{8} & Valeur pour l'instruction \texttt{MOV}\\
\hline
\texttt{ALU\_Opcode}	&  \texttt{4} & Code opération à destination de l'ALU\\
\hline
\texttt{Rm}		&  \texttt{3} & Séléction du registre pour lecture de l'opérande A\\
\hline
\texttt{Rn}		&  \texttt{3} & Sélection du registre pour lecture de l'opérande B\\
\hline
\texttt{Rd}		&  \texttt{3} & Sélection du registre pour enregistrement du résultat\\
\hline
\texttt{RAM\_Addr}	& \texttt{32} & Adresse mémoire des instructions \textit{Load/Store}\\
\hline
\texttt{Load}		&  \texttt{1} & Provenance des données en entrée du banc de registre: 0 pour résultat de l'ALU, 1 pour sortie de la RAM\\
\hline
\texttt{Store}		&  \texttt{1} & 1 pour stocker la valeur du registre \texttt{Rm} à l'adress \texttt{RAM\_Address}\\
\hline
\texttt{PC}		&  \texttt{8} & Compteur ordinal: adresse de la prochaine instruction en ROM\\


\hline
\end{tabular}

\subsection{Sous composants}

\subsubsection{Décodeur d'instruction}

\subsubsection{Shift, add, sub, mov}

\subsubsection{Data Processing}

\subsubsection{Flags APSR}

\subsubsection{Load/Store}

\subsubsubsection{Description}

Le bloc \textit{Load/Store} traite les instructions de lecture/écriture en mémoire (voir \textit{\ref{subsubsec:LoadStore}~\nameref{subsubsec:LoadStore}}).

La sortie \texttt{RAM\_Addr} correspond à l'adresse mémoire à laquelle effectuer l'opération.
Elle est calculée en fonction de la valeur actuelle du \texttt{Stack\_Pointer} et de l'offset provenant de l'instruction.

La sortie \texttt{Store} indique à la mémoire de stocker la donnée du registre Rm à l'adresse \texttt{RAM\_Addr}. La donnée sera écrite au cycle suivant.

La sortie \texttt{Load} indique au processeur de présenter la donnée à l'adresse \texttt{RAM\_ADDR} en entrée du banc de registre (\texttt{DataIn}). La donnée sera disponible au cycle suivant.

La sortie \texttt{PC_Hold} retarde l'incrémentation du \textit{Program Counter} d'un coup d'horloge. La RAM étant synchrone, elle a besoin d'un cycle pour traiter l'opération de lecture/écriture. La donnée lue n'est donc pas disponible immédiatement, et le processeur ne peut pas commencer à exécuter l'instruction suivante.
La sortie \texttt{Load} devra donc elle aussi être retardée d'un cycle.

Si l'entrée \texttt{Enable} est à 0, les sorties sont forcées à 0.

\paragraph{Astuce:} utiliser une bascule D pour activer \texttt{PC\_Hold} et retarder \texttt{Load}.

\subsubsubsection{Interface}

\textbf{Entrées}\\

\begin{tabular}{|l|r|l|}
\hline
\textbf{Port}		& \textbf{Taille} & \textbf{Description}\\
\hline

\texttt{Instruction}	& \texttt{16} & Instruction de lecture/écriture en mémoire à décoder\\
\hline
\texttt{Enable}		&  \texttt{1} & Active le composant. Si 0, les sortie sont forcées à 0\\
\hline
\texttt{Stack\_Pointer}	& \texttt{32} & Valeur courante du pointeur de pile\\
\hline
\texttt{Clk}		&  \texttt{1} & Horloge\\
\hline
\texttt{Reset}		&  \texttt{1} & Remise à zéro\\


\hline
\end{tabular}

\vspace{1em}
\textbf{Sorties}\\

\begin{tabular}{|l|r|l|}
\hline 
\textbf{Port} & \textbf{Taille} & \textbf{Description}\\
\hline

\hline
\texttt{Store}		&  \texttt{1} & Informe d'une opération d'écriture\\
\hline
\texttt{Load}		&  \texttt{1} & Informe d'une opération de lecture\\
\hline
\texttt{PC_Hold}	&  \texttt{1} & Retarde l'incrémentation du compteur ordinal d'un cycle\\
\hline
\texttt{Rm}		&  \texttt{3} & Registre de provenance de la donnée écrite en mémoire\\
\hline
\texttt{Rn}		&  \texttt{3} & Registre inutilisé\\
\hline
\texttt{Rd}		&  \texttt{3} & Registre de destination de la donnée lue en mémoire\\
\hline
\texttt{RAM\_Addr}	&  \texttt{32} Adresse mémoire à laquelle effectuer les opérations\\

\hline
\end{tabular}




\subsubsection{SP Address}

\subsubsubsection{Description}

Le bloc \textit{SP Address} traite les instructions de mise à jour du pointeur de pile (voir \textit{\ref{subsubsec:MiscInstr}~\nameref{subsubsec:MiscInstr}}).

La sortie \texttt{New\_Stack\_Pointer} correspond à la nouvelle valeur du pointeur de pile qui sera enregistré dans le \textit{Stack Pointer}.
Elle est calculée en fonction de la valeur actuelle du \texttt{Stack\_Pointer} et de l'opération en provenance de l'instruction (addition ou soustraction d'un immédiat).

Si l'entrée \texttt{Enable} est à 0, la sortie \texttt{Write\_Enable} est forcée à 0.

\subsubsubsection{Interface}

\textbf{Entrées}\\

\begin{tabular}{|l|r|l|}
\hline
\textbf{Port}		& \textbf{Taille} & \textbf{Description}\\
\hline

\texttt{Instruction}	& \texttt{16} & Instruction de mise à jour du pointeur de pile à décoder\\
\hline
\texttt{Enable}		&  \texttt{1} & Active le composant. Si 0, les sortie sont forcées à 0\\
\hline
\texttt{Stack\_Pointer}	& \texttt{32} & Valeur courante du pointeur de pile\\

\hline
\end{tabular}

\vspace{1em}
\textbf{Sorties}\\

\begin{tabular}{|l|r|l|}
\hline 
\textbf{Port} & \textbf{Taille} & \textbf{Description}\\
\hline

\hline
\texttt{Write\_Enable}		&  \texttt{1} & Le registre du pointeur de pile sera mis à jour avec la valeur \texttt{New\_Stack\_Pointer}\\
\hline
\texttt{New\_Stack\_Pointer}	& \texttt{32} & Nouvelle valeur du pointeur de pile\\

\hline
\end{tabular}




\subsubsection{Conditional}

\subsubsubsection{Description}

Le bloc conditionnel traite les instructions de branchement conditionnel (voir \textit{\ref{subsubsubsec:CondBranch}~\nameref{subsubsubsec:CondBranch}}).

Il vérifie la condition à l'aide des drapeaux du registre \textit{Flags APSR}, selon le tableau  \textit{\ref{subsec:CondFlags}~\nameref{subsec:CondFlags}}.
Si la condition est vérifiée, la sortie \texttt{Verified} passe à 1.

La sortie \texttt{Offset} correspond à l'offset qui sera ajouté au \textit{Program Counter}, en provenance de l'instruction.

Si l'entrée \texttt{Enable} est à 0, la sortie \texttt{Verified} est forcée à 0.

\subsubsubsection{Interface}

\textbf{Entrées}\\

\begin{tabular}{|l|r|l|}
\hline
\textbf{Port}		& \textbf{Taille} & \textbf{Description}\\
\hline

\texttt{Instruction}	& \texttt{16} & Instruction du branchement conditionnel à décoder\\
\hline
\texttt{Enable}		&  \texttt{1} & Active le composant. Si 0, les sortie sont forcées à 0\\
\hline
\texttt{N}		&  \texttt{1} & Drapeau négatif\\
\hline
\texttt{Z}		&  \texttt{1} & Drapeau nul\\
\hline
\texttt{C}		&  \texttt{1} & Drapeau retenue\\
\hline
\texttt{V}		&  \texttt{1} & Drapeau dépassement de capacité\\


\hline
\end{tabular}

\vspace{1em}
\textbf{Sorties}\\

\begin{tabular}{|l|r|l|}
\hline 
\textbf{Port} & \textbf{Taille} & \textbf{Description}\\
\hline

\hline
\texttt{Verified}	&  \texttt{1} & La condition est vérifiée\\
\hline
\texttt{Offset}		&  \texttt{8} & Offset à appliquer au Program Counter si la condition est vérifiée\\

\hline
\end{tabular}



\subsubsection{Program Counter}

\subsubsubsection{Description}

Le compteur ordinal (\textit{Program Counter}), aussi appelé pointeur d'instruction (\textit{Instruction Pointer}),
est un compteur 8 bits dont la valeur donne l'adresse de la prochaine instruction à exécuter.
Il est déjà implémenté directement dans le contrôleur.

Il s'incrémente automatiquement à chaque coup d'horloge lorsque le signal \texttt{Count} est à l'état haut.
Le signal \texttt{PC\_Hold} sortant du sous-composant \textit{Load/Store} retarde cette incrémentation d'un cycle afin de laisser le temps à la RAM de présenter la donnée sélectionnée sur sa sortie.
En effet, étant synchrone, elle n'agit qu'au coup d'horloge suivant.

Lorsque le signal \texttt{Load} est à l'état haut, le compteur charge la valeur suivante à partir de son entrée au prochain coup d'horloge.
Les instructions de branchement (voir \textit{\ref{subsubsec:Branching}~\nameref{subsubsec:Branching}}) du sous-composant \textit{Conditional} exploitent cette possibilité
afin d'altérer le flot d'exécution du programme en sautant à une certaine adresse.

\paragraph{Remarque:} afin d'être cohérent avec le comportement d'un vrai \texttt{Cortex-M0} et donc rester compatible avec les programmes compilés par \texttt{GCC} ou \texttt{LLVM},
l'offset du branchement est incrémenté de 3.

\subsubsubsection{Interface}

\textbf{Entrées}\\

\begin{tabular}{|l|r|l|}
\hline
\textbf{Port}		& \textbf{Taille} & \textbf{Description}\\
\hline

\texttt{Data}		&  \texttt{8} & Valeur du compteur à définir si \texttt{Load} est à l'état haut\\
\hline
\texttt{Count}		&  \texttt{1} & Active l'incrémentation automatique du compteur\\
\hline
\texttt{UpDown}		&  \texttt{1} & 0: décrémente, 1: incrémente. Forcé à 1.\\
\hline
\texttt{Load}		&  \texttt{1} & Charge la valeur à partir de l'entrée \texttt{Data}\\
\hline
\texttt{Clk}		&  \texttt{1} & Horloge\\
\hline
\texttt{Clear}		&  \texttt{1} & Remise à Zero\\
\hline


\hline
\end{tabular}

\vspace{1em}
\textbf{Sorties}\\

\begin{tabular}{|l|r|l|}
\hline 
\textbf{Port} & \textbf{Taille} & \textbf{Description}\\
\hline

\hline
\texttt{Output}		&  \texttt{8} & Valeur courante du compteur ordinal\\
\hline
\texttt{Carry}		&  \texttt{1} & 1 si le compteur atteint sa valeur maximale. Non utilisé ici.\\

\hline
\end{tabular}


\subsubsection{Stack Pointer}

\subsubsubsection{Description}

Le pointeur de pile (\textit{Stack Pointer}) est un simple registre 32 bits indiquant l'adresse en mémoire du début de la pile.
Il est déjà implémenté directement dans le contrôleur.

Son contenu est modifié par les instructions \texttt{ADD} et \texttt{SUB} 
(voir \textit{\ref{subsubsec:MiscInstr}~\nameref{subsubsec:MiscInstr}}) du sous-composant \textit{SP Address}.

Son contenu est utilisé par les instructions \texttt{LDR} et \texttt{STR} 
(voir \textit{\ref{subsubsec:LoadStore}~\nameref{subsubsec:LoadStore}}) du sous-composant \textit{Load/Store}.

\paragraph{Remarque:} en général dans un programme, on commence par décrémenter (avec \texttt{SUB}) le pointeur de pile de la quantité d'espace mémoire dont on aura besoin. Par la suite, pour les accès mémoire on utilisera \texttt{LDR} et \texttt{STR} avec un offset pour sélectionner le bon emplacement dans la pile. À la fin, on incrémente (avec \texttt{ADD}) le pointeur de pile pour revenir à l'état initial.

On peut dire que la pile grandit vers le bas.

\subsubsubsection{Interface}

\textbf{Entrées}\\

\begin{tabular}{|l|r|l|}
\hline
\textbf{Port}		& \textbf{Taille} & \textbf{Description}\\
\hline

\texttt{Data}		& \texttt{32} & Nouvelle valeur du pointeur de pile\\
\hline
\texttt{Enable}		&  \texttt{1} & Active l'enregistrement de la valeur au prochain coup d'horloge\\
\hline
\texttt{Clk}		&  \texttt{1} & Horloge\\
\hline
\texttt{Reset}		&  \texttt{1} & Remise à Zero\\
\hline


\hline
\end{tabular}

\vspace{1em}
\textbf{Sorties}\\

\begin{tabular}{|l|r|l|}
\hline 
\textbf{Port} & \textbf{Taille} & \textbf{Description}\\
\hline

\hline
\texttt{Output}		& \texttt{32} & Valeur courante du pointeur de pile\\

\hline
\end{tabular}

